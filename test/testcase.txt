valgrind --leak-check=full --suppressions=readline.supp --show-leak-kinds=all --track-fds=yes --trace-children=yes ./minishell

#1
<< OK | | cat -e
#should has error

#2
<<OK|cat -e
#should print nothing

#3
<<OK|cat -e>>
#should has error

#4
ls|
#should has error

#5
<< OK |cat -e|cat -e  
<< OK #should not has error
<< |a #should has error


#6
check if here doc unlink temp files

#7
#echo $_

#8
export 比env少一行

#9
<< OK |<< KO| << KO cat
<< OK | << KO cat|<<KO
#should has error

#10
echo hello|cat
ls|echo hello|cat

#11
bash ls|./minishell

#12
heredoc ctrl c
segfault

#13
< test.sh|cat|<test.sh<<OK cat -e
<< OK cat|< test.sh

#14
< test.sh cat|cat -e > outfile >>outfile2
when outfile has no access

#15
ctrl\ quit in execution

#16
echo "$HOME"'$HOME'

#17
'/bin/ls abbb'
no such file...

#18
$? + $?

#19
echo "cat|cat -e|"
echo "cat|cat -e|"
echo "cat$HOME|cat -e|"
echo "cat$HOME|cat -e'test'|"

#20
valgrind --leak-check=full --suppressions=readline.supp --show-leak-kinds=all --track-fds=yes --trace-children=yes ./minishell

#21
clear   2fds hasn't closed

#22
valgrind   << OK cat      this case is ok without leak and unclosed fds

#23
ctrl D   ok
<<  ctrl D  ok

#24
echo | |env     leak
ls >> >> cat     leak
ls||cat    no leak
<< OK |cat    when there is no command in child, there will be leak
<< OK         leak
<< OK cat      ctrl C break here doc      leak and error
<< OK cat      ctrl D break here doc      OK
<< OK cat |sleep 10      OK
< test.sh > outfile    no command leak  ??
< test.sh cat > outfile     OK


#25
dup in redin and redout need to protect

#26
echo "Hello||world|"|echo              OK
echo "Hello||world|"lets'do a test'    OK
echo "Hello||world|"		       OK										
echo "Hello||world|                    OK
echo "cat lol.c | cat > lol.c$HOME"    OK
echo "cat lol.c | cat > lol.c"	       OK
echo "Hello $HOME"		       OK
echo 'Hello $HOME'                     OK
echo "Hello $HOME"test'$HOME'          OK
<< OK cat     '$HOME' in here doc      OK
<< OK cat     "$HOME" in here doc      OK
<< OK cat     $HOME in here doc        OK

#26
env                                   OK
export A=10			     invalid read & leak KO 
export 3			     invalid read & leak KO 
export A=1 B=2			     invalid read & leak KO 
export A B C			     invalid read & leak KO

unset				      OK
unset HOME			      OK
unset PATH    ls  
	bash: ls: No such file or directory
	minishell: ls: command not found
	
	in general when command does't exist there are memory errors.

#27
export PATH=/home/shuwang/sw/FINISHED_PROJECT/so_long:/home/shuwang/sw/philo/philo/
philo				  OK
export PATH=/home/shuwang/sw/philo/philo/:/home/shuwang/sw/FINISHED_PROJECT/so_long
philo                             OK

#28
cat lexer.c|grep int| cat -e>outfile1>outfile2   OK with or without outifile1 permission

#29
cat|cat|ls      OK

#30
echo "'Hello$USER'"  	OK
echo 'Hello$USER'	OK

#31
echo hello>outfile               builtin in parent KO
echo hello>>outfile		 builtin in parent KO
ls > outfile			 non builtin in children OK
ls >> outfile			 non builtin in children OK
env|echo "Hello" > outfile	 builtin in children OK
env|echo "Hello" >> outfile	 builtin in children OK

builtin doesn't read from stdin so can't test redin in parent, maybe don't need

#32
normal control c  OK

#33
write here_doc function      set message

#34
when abs path doesn't exist, there is an error

#35
yf&sw@minishell*main$ /home/shuwang/sw/minishell/src_sw

double free

#35
first time open a file, there will be error when copy file

#36
double free when in a directory

#37
when there is a lot of space there will be error

#38
ctrl + c break
cat|cat |cat |echo     echo $?  0
sleep 10|sleep 5|sleep 6|echo  echo $? 0
cat     echo $? 130
sleep 10     echo $? 130

#39
Salut a tous, si je fais 
export C=" a       b  c   "
echo $C
le resultat  est de   "a b c"     avec un effet de trim et une seule espace au milieu
est-ce qu'on doit gerer dans minishell?

#40
un autre cas est
export A="ls -l" B="cat -e"
$A|$B    functionne comme deux commands normaux,
mais si je fais
export A="ls -l > outfile"
$A      le resultat est:
ls: cannot access '>': No such file or directory
ls: cannot access 'outfile': No such file or directory

si on fait expansion, quand le variable d'environnement contient | > ou < etc, on les interprete comme caracters normaux?

export A="

#41 TESTER
	test24:
		export hello
		export  mini: no hello  bash: has hello
		env	mini: no hello  bash: no hello
	
	test25:
		export HELLO=123
		export  mini: HELLO=123  bash: HELLO="123"
		env	mini: HELLO=123  bash: HELLO=123
	
	test27:
		export HELLO=123 A
		export  mini: HELLO=123  bash: HELLO="123" A
		env	mini: HELLO=123  bash: HELLO=123
	test28:
		same as previous cases miss "" for export
	test29:
		export hello wolrd
		should has hello   wolrd in export not in env
		
	test65: ❌ echo <"./test_files/infile" <missing <"./test_files/infile" 
		mini exit code =
		bash exit code = 1
		mini error = ( No such file or directory command not found command not found command not found command not found)
		bash error = ( No such file or directory)
		
	test105:
		cat >./outfiles/outfile01 <missing     both no such file but in bash created the file
		
	test108:
		cat >./outfiles/outfile01 <missing >./test_files/invalid_permission
		if outfiles/ doesn't exist
			minishell: missing: No such file or directory
			bash: ./outfiles/outfile01: No such file or directory
		else
			minishell: missing: No such file or directory
			bash: missing: No such file or directory
			but still create the file
	
	test120:
		ls >>./test_files/invalid_permission >>./outfiles/outfile02 <missing
			minishell: missing: No such file or directory
			bash: ./test_files/invalid_permission: Permission denied
			
	test127:
		echo hi >>./test_files/invalid_permission >./outfiles/outfile01 | echo bye
			minishell: ./test_files/invalid_permission: Permission denied
			bye
			outfile01 created
			
			bye
			bash: ./test_files/invalid_permission: Permission denied
			outfile01 not created
			
	test138:
		missing.out
			minishell: missing.out: command not found
			missing.out: command not found  (no bash)
	
	test139:
		"aaa"
		minishell: aaa: command not found
		Command 'aaa' not found, did you mean:
  			command 'aa' from deb astronomical-almanac (5.6-7)
  			command 'aha' from deb aha (0.5.1-2)
  			command 'ara' from deb python3-ara (1.5.7-1)
  			command 'jaaa' from deb jaaa (0.9.2-1)

	test141:
		yf&sw@minishell*minishell_tester$ ./test_files
			minishell: test_files: Is a directory
			(bash) test_files: command not found
	
	test143:
		minishell.h
			(bash)minishell.h: command not found
			minishell: minishell.h: command not found
		
	
	

		
	


